# -*- coding: utf-8 -*-
"""Copy_of_berlin52.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NafA1uSLvuu0vkeSMRHMU-2xCNsALH1I
"""

import math
import random as random
import numpy as np
import time
from statistics import mean

POP_SIZES = [200,300,400]
NUM_ITERATIONS = [200,300]
ELITE_SIZES = [40,60]
TOURNAMENT_SIZES = [5,7]
MUTATION_PROBABILITIES = [0.03,0.05]
LS_ITERATIONS = 5

BEST_POP_SIZE = 0
BEST_NUM_ITERATIONS = 0
BEST_ELITE_SIZE = 0
BEST_TOURNAMENT_SIZE = 0
BEST_MUTATION_PROBABILITY = 0
BEST_SCORE = float('inf')

class Individual:
  def __init__(self, numVertices, costMatrix):
    self.code = [i for i in range(1, numVertices+1)]
    random.shuffle(self.code)
    self.fitness = self.calculateFitness(costMatrix)
  
  def calculateFitness(self, costMatrix):
    fitness = 0
    totalWait = 0
    for i in range(len(self.code)-1):
      a = self.code[i]-1
      b = self.code[i+1]-1
      totalWait += costMatrix[a][b]
      fitness += totalWait
    return fitness
    
  def __lt__(self, other):
         return self.fitness < other.fitness

def readInput(filename):
  myfile = open(filename, 'r')
  lines = myfile.readlines()

  data = lines[6:-1]
  xs = []
  ys = []
  numVertices = len(data)
  for i in range(numVertices):
    line = data[i].split(" ")
    xs.append(float(line[1].strip()))
    ys.append(float(line[2].strip()))

  distances = []
  for i in range(numVertices):
    row = []
    for j in range(numVertices):
      dist = math.sqrt((xs[j]-xs[i])**2 + (ys[j]-ys[i])**2)
      row.append(dist)
    distances.append(row)
  for i in range(numVertices):
    for j in range(numVertices):
      distances[i][j] = round(distances[i][j],2)

  return numVertices, distances

def initializePopulation(numVertices, costMatrix, population_size):
  population = []
  newPopulation = []
  for i in range(population_size):
    population.append(Individual(numVertices, costMatrix))
    newPopulation.append(Individual(numVertices, costMatrix))
  return population, newPopulation

def selection(population, tour_size, pop_size):
  min = float('inf')
  p = -1
  for i in range(tour_size):
    index = random.randrange(pop_size)
    if population[index].fitness < min:
      min = population[index].fitness
      p = index
  return p

def crossover(child1, child2, parent1, parent2):
  n = len(child1.code)

  startIndex = random.randrange(n)
  endIndex = random.randrange(n)
  if startIndex > endIndex:
    startIndex, endIndex = endIndex, startIndex
  
  used = set()
  child1.code[startIndex:endIndex+1] = parent1.code[startIndex:endIndex+1]
  used.update(parent1.code[startIndex : endIndex+1])
  ind = endIndex+1
  if ind==n:
    ind = 0
  
  for i in range(endIndex+1, n):  
    if parent2.code[i] not in used:
      child1.code[ind] = parent2.code[i]
      used.add(parent2.code[i])
      ind += 1
      if ind>=n:
        ind = 0

  for i in range(endIndex+1):
    if ind == startIndex:
      break
    if parent2.code[i] not in used:
      child1.code[ind] = parent2.code[i]
      used.add(parent2.code[i])
      ind+=1
      if ind>=n:
        ind = 0
  
  used.clear()
  child2.code[startIndex:endIndex+1] = parent2.code[startIndex:endIndex+1]
  used.update(parent2.code[startIndex : endIndex+1])
  ind = endIndex+1
  if ind==n:
    ind = 0

  for i in range(endIndex+1, n):  
    if parent1.code[i] not in used:
      child2.code[ind] = parent1.code[i]
      used.add(parent1.code[i])
      ind += 1
      if ind>=n:
        ind = 0

  for i in range(endIndex+1):
    if ind==startIndex:
      break
    if parent1.code[i] not in used:
      child2.code[ind] = parent1.code[i]
      used.add(parent1.code[i])
      ind+=1
      if ind>=n:
        ind = 0

def mutationSwitch(individual, mut_prob):
  if random.random() <= mut_prob:
    n = len(individual.code)
    index1 = random.randrange(n)
    index2 = random.randrange(n)
    individual.code[index1], individual.code[index2] = individual.code[index2], individual.code[index1]

def mutationInsert(individual, mut_prob):
  if random.random() <= mut_prob:
    n = len(individual.code)
    index1 = random.randrange(n-2)
    index2 = random.randrange(index1+1, n)
    i = index2
    while i>= index1+2:
      individual.code[i], individual.code[i-1] = individual.code[i-1], individual.code[i]
      i-=1

def mutationInvert(individual, mut_prob):
  if random.random() <= mut_prob:
    n = len(individual.code)
    index1 = random.randrange(n-1)
    index2 = random.randrange(index1+1, n)
    segLen = index2 - index1 + 1
    print(f"{index1} - {index2}")
    if segLen%2==0:
      segLen-=1
    segLen//=2
    print(segLen)
    for i in range(segLen+1):
      individual.code[index1+i], individual.code[index2-i] = individual.code[index2-i], individual.code[index1+i]

def mutationMix(individual, mut_prob):
  if random.random() <= mut_prob:
    n = len(individual.code)
    index1 = random.randrange(n-1)
    index2 = random.randrange(index1+1, n)
    print(f"{index1} - {index2}")
    copy = individual.code[index1:index2+1]
    random.shuffle(copy)
    individual.code[index1:index2+1] = copy

def swap(individual, startIndex, endIndex):
  individual.code[startIndex], individual.code[endIndex] = individual.code[endIndex], individual.code[startIndex]

def calcSumsMiddle(ind, startIndex, costMatrix):
  sum = 0
  allSum = 0
  for i in range(startIndex-1, startIndex+2):
    a = ind.code[i]-1
    b = ind.code[i+1]-1
    sum += costMatrix[a][b]
    allSum += sum
  return sum, allSum

def calcNewFitness(ind, startIndex, costMatrix, sum1, allsum1, sum2, allsum2):
  return ind.fitness + (len(ind.code)-startIndex-3)*(sum2-sum1) + allsum2-allsum1

def localSearch(individual, costMatrix):
  n = len(individual.code)
  bestFitness = individual.fitness

  for i in range(LS_ITERATIONS):
    oldFitness = individual.fitness
    startIndex = random.randrange(1, n-2)
    sum1, allsum1 = calcSumsMiddle(individual, startIndex, costMatrix)
    swap(individual, startIndex, startIndex+1)
    sum2, allsum2 = calcSumsMiddle(individual, startIndex, costMatrix)
    individual.fitness = calcNewFitness(individual, startIndex, costMatrix, sum1, allsum1, sum2, allsum2)
    if individual.fitness < bestFitness:
      bestFitness = individual.fitness
    else:
      swap(individual, startIndex, startIndex+1)
      individual.fitness = oldFitness

def findBestSolution2(filename, pop_size, num_iter, elite_size, torunament_size, mutation_prob):
  numVertices, costMatrix = readInput(filename)
  population, newPopulation = initializePopulation(numVertices, costMatrix,pop_size)

  startTime = time.time()
  for iter in range(num_iter):
    population.sort()
    bestFitness = population[0].fitness
    # print(bestFitness)
    # print(population[0].code)
    
    newPopulation = []
    for i in range(pop_size):
      newPopulation.append(Individual(numVertices, costMatrix))

    newPopulation[:elite_size] = population[:elite_size]
    for i in range(elite_size, pop_size, 2):
      p1 = selection(population,torunament_size, pop_size)
      p2 = selection(population,torunament_size, pop_size)
      crossover(newPopulation[i], newPopulation[i+1], population[p1], population[p2])
      mutationSwitch(newPopulation[i], mutation_prob)
      mutationSwitch(newPopulation[i+1], mutation_prob)

      newPopulation[i].fitness = newPopulation[i].calculateFitness(costMatrix)
      newPopulation[i+1].fitness = newPopulation[i+1].calculateFitness(costMatrix)

      localSearch(newPopulation[i], costMatrix)
      localSearch(newPopulation[i+1], costMatrix)

    population = newPopulation

  timeDiff = time.time() - startTime
  return population[0].fitness, timeDiff

graphs = ["berlin52.txt", "dantzig42.txt","att48.txt","eil51.txt","eil101.txt","eli76.txt","lin105.txt","rat99.txt","st70.txt"]

for graph in graphs:
  bestValue = float('inf')
  valueSum = 0
  timeSum = 0
  for i in range(10):
    value, timeRes = findBestSolution2(graph, 400, 300, 60, 7, 0.03)
    if value < bestValue:
      bestValue = value
    valueSum += value
    timeSum += timeRes
  valueAvg = valueSum/10
  timeAvg = timeSum/10
  print(f"Graph: {graph}, Best value: {round(bestValue,2)}, Avg. value: {round(valueAvg,2)}, Avg. time: {round(timeAvg,2)}")

print("-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~")
print("-~-~-~-~-~-~-~-~-~-~-~-~-~-~-WITHOUT LOCAL SEARCH~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~")
print("-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~")

def findBestSolution3(filename, pop_size, num_iter, elite_size, torunament_size, mutation_prob):
  numVertices, costMatrix = readInput(filename)
  population, newPopulation = initializePopulation(numVertices, costMatrix,pop_size)

  startTime = time.time()
  for iter in range(num_iter):
    population.sort()
    bestFitness = population[0].fitness
    # print(bestFitness)
    # print(population[0].code)
    
    newPopulation = []
    for i in range(pop_size):
      newPopulation.append(Individual(numVertices, costMatrix))

    newPopulation[:elite_size] = population[:elite_size]
    for i in range(elite_size, pop_size, 2):
      p1 = selection(population,torunament_size, pop_size)
      p2 = selection(population,torunament_size, pop_size)
      crossover(newPopulation[i], newPopulation[i+1], population[p1], population[p2])
      mutationSwitch(newPopulation[i], mutation_prob)
      mutationSwitch(newPopulation[i+1], mutation_prob)

      newPopulation[i].fitness = newPopulation[i].calculateFitness(costMatrix)
      newPopulation[i+1].fitness = newPopulation[i+1].calculateFitness(costMatrix)

    population = newPopulation

  timeDiff = time.time() - startTime
  return population[0].fitness, timeDiff

for graph in graphs:
  bestValue = float('inf')
  valueSum = 0
  timeSum = 0
  for i in range(10):
    value, timeRes = findBestSolution3(graph, 400, 300, 60, 7, 0.03)
    if value < bestValue:
      bestValue = value
    valueSum += value
    timeSum += timeRes
  valueAvg = valueSum/10
  timeAvg = timeSum/10
  print(f"Graph: {graph}, Best value: {round(bestValue,2)}, Avg. value: {round(valueAvg,2)}, Avg. time: {round(timeAvg,2)}")
